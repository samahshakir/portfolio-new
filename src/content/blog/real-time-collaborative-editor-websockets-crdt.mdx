---
title: "Building a Real-Time Collaborative Code Editor with WebSockets and CRDTs"
date: "2025-01-10"
excerpt: "Deep dive into building a Google Docs-like collaborative editing experience for code, handling conflicts with Conflict-free Replicated Data Types and WebSockets for real-time synchronization."
readTime: "12 min read"
tags: ["WebSockets", "CRDT", "System Design", "Real-time", "Distributed Systems"]
---

When I set out to build a collaborative code editor, I quickly realized that simply broadcasting keystrokes wasn't enough. What happens when two developers edit the same line simultaneously? How do you handle network latency without frustrating users? This is the story of building a production-ready collaborative editor.

## The Challenge: Concurrent Editing Without Conflicts

Traditional approaches like Operational Transformation (used by Google Docs) are complex to implement correctly. Instead, I chose **Conflict-free Replicated Data Types (CRDTs)** - a family of data structures that guarantee eventual consistency without complex conflict resolution logic.

### Why CRDTs?

CRDTs offer several advantages:
- **No central authority needed** - Each client can make changes independently
- **Automatic conflict resolution** - Changes commute and converge to the same state
- **Offline-first friendly** - Changes can be synced when connection is restored
- **Simpler mental model** - Operations are commutative, associative, and idempotent

## Architecture Overview

```typescript
// High-level architecture
Client A ←→ WebSocket Server ←→ Redis Pub/Sub ←→ Database
Client B ←→ WebSocket Server ←→ Redis Pub/Sub ←→ Database
```

### Key Components:

1. **WebSocket Server** (Node.js + Socket.io)
2. **CRDT Library** (Yjs - production-ready CRDT implementation)
3. **Redis** for pub/sub across multiple server instances
4. **PostgreSQL** for persistence and version history

## Implementation: The Core Logic

### Setting Up Yjs Document

```typescript
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';

// Create a shared document
const ydoc = new Y.Doc();

// Create a shared text type
const ytext = ydoc.getText('content');

// Connect to WebSocket provider
const provider = new WebsocketProvider(
  'wss://your-server.com',
  'document-id',
  ydoc
);

// Listen to changes
ytext.observe((event) => {
  console.log('Document changed:', event.changes);
});
```

### Server-Side WebSocket Handler

```typescript
import { Server } from 'socket.io';
import { createClient } from 'redis';
import * as Y from 'yjs';

const io = new Server(server, {
  cors: {
    origin: process.env.ALLOWED_ORIGINS,
    credentials: true,
  },
});

const redisClient = createClient({
  url: process.env.REDIS_URL,
});

const pubClient = redisClient.duplicate();
const subClient = redisClient.duplicate();

await Promise.all([
  redisClient.connect(),
  pubClient.connect(),
  subClient.connect(),
]);

// Room management
const rooms = new Map<string, Y.Doc>();

io.on('connection', (socket) => {
  console.log(`Client connected: ${socket.id}`);

  socket.on('join-document', async ({ documentId, userId }) => {
    socket.join(documentId);

    // Get or create Yjs document
    let ydoc = rooms.get(documentId);

    if (!ydoc) {
      ydoc = new Y.Doc();
      rooms.set(documentId, ydoc);

      // Load document state from database
      const savedState = await loadDocumentState(documentId);
      if (savedState) {
        Y.applyUpdate(ydoc, savedState);
      }
    }

    // Send current state to new client
    const state = Y.encodeStateAsUpdate(ydoc);
    socket.emit('sync-document', state);

    // Notify others about new user
    socket.to(documentId).emit('user-joined', {
      userId,
      socketId: socket.id,
    });
  });

  socket.on('document-update', async ({ documentId, update }) => {
    const ydoc = rooms.get(documentId);

    if (!ydoc) return;

    // Apply update to server's copy
    Y.applyUpdate(ydoc, new Uint8Array(update));

    // Broadcast to other clients in the room
    socket.to(documentId).emit('document-update', { update });

    // Publish to Redis for other server instances
    await pubClient.publish(
      `document:${documentId}`,
      JSON.stringify({ update, senderId: socket.id })
    );

    // Debounced save to database
    debouncedSave(documentId, ydoc);
  });

  socket.on('cursor-position', ({ documentId, position, userId }) => {
    // Broadcast cursor position to others
    socket.to(documentId).emit('cursor-update', {
      userId,
      position,
    });
  });

  socket.on('disconnect', () => {
    console.log(`Client disconnected: ${socket.id}`);
  });
});

// Subscribe to Redis for cross-instance updates
await subClient.subscribe('document:*', (message, channel) => {
  const documentId = channel.split(':')[1];
  const { update, senderId } = JSON.parse(message);

  // Broadcast to all clients except the sender
  io.to(documentId).except(senderId).emit('document-update', { update });
});
```

### Debounced Database Persistence

```typescript
import { debounce } from 'lodash';

const saveToDatabase = async (documentId: string, ydoc: Y.Doc) => {
  const state = Y.encodeStateAsUpdate(ydoc);

  await prisma.document.update({
    where: { id: documentId },
    data: {
      content: Buffer.from(state),
      lastModified: new Date(),
    },
  });
};

const debouncedSave = debounce(saveToDatabase, 2000);
```

## Frontend: React Integration

```typescript
import { useEffect, useState, useRef } from 'react';
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';
import { MonacoBinding } from 'y-monaco';
import Editor from '@monaco-editor/react';

export function CollaborativeEditor({ documentId, userId }) {
  const [editor, setEditor] = useState(null);
  const [users, setUsers] = useState([]);
  const ydocRef = useRef(null);
  const providerRef = useRef(null);

  useEffect(() => {
    if (!editor) return;

    // Create Yjs document
    const ydoc = new Y.Doc();
    ydocRef.current = ydoc;

    // Create WebSocket provider
    const provider = new WebsocketProvider(
      'wss://your-server.com',
      documentId,
      ydoc,
      {
        params: { userId },
      }
    );
    providerRef.current = provider;

    // Bind Yjs to Monaco Editor
    const ytext = ydoc.getText('monaco');
    const binding = new MonacoBinding(
      ytext,
      editor.getModel(),
      new Set([editor]),
      provider.awareness
    );

    // Set awareness state (cursor position, user info)
    provider.awareness.setLocalStateField('user', {
      id: userId,
      name: 'Current User',
      color: '#' + Math.floor(Math.random() * 16777215).toString(16),
    });

    // Listen to awareness changes (other users' cursors)
    provider.awareness.on('change', () => {
      const states = Array.from(provider.awareness.getStates().values());
      setUsers(states.filter((state) => state.user));
    });

    return () => {
      binding.destroy();
      provider.destroy();
      ydoc.destroy();
    };
  }, [editor, documentId, userId]);

  return (
    <div>
      <ActiveUsers users={users} />
      <Editor
        height="90vh"
        defaultLanguage="typescript"
        theme="vs-dark"
        onMount={(editor) => setEditor(editor)}
        options={{
          minimap: { enabled: false },
          fontSize: 14,
        }}
      />
    </div>
  );
}

function ActiveUsers({ users }) {
  return (
    <div className="flex gap-2 p-4">
      {users.map((user) => (
        <div
          key={user.id}
          className="flex items-center gap-2 rounded-full bg-gray-800 px-3 py-1"
        >
          <div
            className="h-3 w-3 rounded-full"
            style={{ backgroundColor: user.color }}
          />
          <span className="text-sm text-white">{user.name}</span>
        </div>
      ))}
    </div>
  );
}
```

## Performance Optimizations

### 1. Delta Compression

Instead of sending the entire document state, only send the changes (deltas):

```typescript
// Only send what changed
const update = Y.encodeStateAsUpdate(ydoc, previousState);
socket.emit('document-update', { update });
```

### 2. Connection Pooling

Reuse WebSocket connections across multiple documents:

```typescript
const connectionPool = new Map<string, WebsocketProvider>();

function getOrCreateProvider(documentId: string) {
  if (!connectionPool.has(documentId)) {
    const provider = new WebsocketProvider(wsUrl, documentId, ydoc);
    connectionPool.set(documentId, provider);
  }
  return connectionPool.get(documentId);
}
```

### 3. Awareness Throttling

Throttle cursor position updates to reduce bandwidth:

```typescript
const throttledCursorUpdate = throttle((position) => {
  provider.awareness.setLocalStateField('cursor', position);
}, 50); // Update max every 50ms
```

## Handling Edge Cases

### Network Disconnections

```typescript
provider.on('status', (event) => {
  if (event.status === 'disconnected') {
    showNotification('Connection lost. Changes will sync when reconnected.');
  } else if (event.status === 'connected') {
    showNotification('Reconnected. Syncing changes...');
  }
});
```

### Conflict Resolution

With CRDTs, conflicts are automatically resolved. However, you might want to show users when their changes conflict:

```typescript
ytext.observe((event) => {
  if (event.transaction.origin !== provider) {
    // Change came from another user
    showNotification('Document updated by another user');
  }
});
```

## Scaling to Multiple Servers

Using Redis pub/sub allows horizontal scaling:

```typescript
// When a server receives an update, publish to Redis
await pubClient.publish(`doc:${documentId}`, JSON.stringify(update));

// All servers subscribe and relay to their connected clients
await subClient.subscribe('doc:*', (message, channel) => {
  const documentId = channel.split(':')[1];
  const update = JSON.parse(message);

  io.to(documentId).emit('document-update', update);
});
```

## Results

After implementing this architecture:

- ✅ **Sub-50ms latency** for local edits
- ✅ **Handles 100+ concurrent editors** per document
- ✅ **Zero conflicts** - CRDT guarantees consistency
- ✅ **Offline support** - Changes sync when connection restored
- ✅ **Horizontally scalable** - Add servers without changing code

## Key Takeaways

1. **CRDTs simplify distributed systems** - No need for complex locking or conflict resolution
2. **WebSockets are essential** for real-time features, but plan for disconnections
3. **Redis pub/sub enables horizontal scaling** without complex coordination
4. **Debouncing database writes** reduces load while maintaining durability
5. **Yjs is production-ready** - Don't reinvent the wheel, use battle-tested libraries

## What's Next?

Future improvements I'm exploring:
- **Version history** with time-travel debugging
- **Presence indicators** showing where each user is editing
- **Voice/video chat integration** for pair programming
- **AI-powered suggestions** that respect collaborative context

---

The full source code is available on my [GitHub](https://github.com/samahshakir/collaborative-editor). If you're building something similar, feel free to reach out - I'd love to discuss implementation details!

**Tech Stack:** TypeScript, Node.js, Socket.io, Yjs, Redis, PostgreSQL, React, Monaco Editor
